apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: expense
  labels:
    tier: web
spec:
  progressDeadlineSeconds: 600
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app: frontend
      tier: web
      project: expense
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 25%
      maxSurge: 25%
  template:
    metadata:
      labels:
        app: frontend
        tier: web
        project: expense
    spec:
      # affinity:
      #   podAntiAffinity:
      #     preferredDuringSchedulingIgnoredDuringExecution:
      #     - podAffinityTerm:
      #         labelSelector:
      #           matchExpressions:
      #           - key: app
      #             operator: In
      #             values:
      #             - frontend
      #         topologyKey: kubernetes.io/hostname
      #       weight: 100  
      serviceAccount: frontend
      serviceAccountName: frontend
      terminationGracePeriodSeconds: 10
      securityContext:
        runAsUser: 0
      containers:
      - name: frontend
        image: srikanthhg/frontend:expense
        ports:
        - containerPort: 80
        imagePullPolicy: IfNotPresent
        envFrom:
        - configMapRef:
            name: frontend
        resources:
          requests:
            cpu:  100m
            memory: 128Mi
          # limits is greater than or equal to requests
          limits:
            cpu: 100m
            memory: 128Mi
        readinessProbe:
          tcpSocket:
            port: 80
          initialDelaySeconds: 15
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 80
          initialDelaySeconds: 3
          periodSeconds: 3
        # securityContext:
          # allowPrivilegeEscalation: true
        #   readOnlyRootFilesystem: true
          # fsGroup: 1001
          # runAsGroup: 1001
        #   runAsNonRoot: true
          # runAsUser: 1001 # Run as root user
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - name: nginx-conf
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf # This ensures that only the specific file (nginx.conf) from the ConfigMap is mounted at the specified path. or Ensures that only the file nginx.conf is mounted, rather than the entire ConfigMap.
          readOnly: true # This ensures the file mounted from the ConfigMap is read-only and cannot be modified by the container.
        # NEW: Mount Azure File Share
        - name: azurefile
          mountPath: /mnt/azurefile
        # NEW: Mount Azure Blob
        - name: blob
          mountPath: /mnt/blob
      volumes:
      - name: nginx-conf
        configMap:
          name: frontend
          items:
          - key: nginx.conf # This is the key in the ConfigMap.
            path: nginx.conf # This is the path (file name) that will be used inside the container.
      # NEW VOLUMES
      - name: azurefile
        persistentVolumeClaim:
          claimName: pvc-azurefile
      - name: blob
        persistentVolumeClaim:
          claimName: pvc-blob
      restartPolicy: Always
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-azurefile
  namespace: expense
spec:
  accessModes:
    - ReadWriteMany
  storageClassName: azurefile-csi
  volumeName: azurefile
  resources:
    requests:
      storage: 5Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-blob
  namespace: expense
spec:
  accessModes:
    - ReadWriteMany
  storageClassName: ""
  volumeName: pv-blob
  resources:
    requests:
      storage: 5Gi
---
apiVersion: v1
kind: PersistentVolume
metadata:
  annotations:
    pv.kubernetes.io/provisioned-by: file.csi.azure.com
  name: azurefile
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain
  storageClassName: azurefile-csi
  csi:
    driver: file.csi.azure.com
    volumeHandle: "MC_myRG_myaksCluster-eastus_eastus#mystorageacceastus#mytestshareeastus"  # make sure this volumeid is unique for every identical share in the cluster
    volumeAttributes:
      shareName: mytestshareeastus
    nodeStageSecretRef:
      name: azure-secret
      namespace: expense
  mountOptions:
    - dir_mode=0777
    - file_mode=0777
    - uid=0
    - gid=0
    - mfsymlinks
    - cache=strict
    - nosharesock
    - nobrl  # disable sending byte range lock requests to the server and for applications which have challenges with posix locks
---
apiVersion: v1
kind: PersistentVolume
metadata:
  annotations:
    pv.kubernetes.io/provisioned-by: blob.csi.azure.com
  name: pv-blob
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteMany
  persistentVolumeReclaimPolicy: Retain  # If set as "Delete" container would be removed after pvc deletion
  storageClassName: ""
  mountOptions:
    - -o allow_other
    - --file-cache-timeout-in-seconds=120
  csi:
    driver: blob.csi.azure.com
    # make sure volumeid is unique for every identical storage blob container in the cluster
    # character `#` and `/` are reserved for internal use and cannot be used in volumehandle
    volumeHandle: mystorageacceastus_mytestcontainer
    volumeAttributes:
      # resourceGroup: MC_myRG_myaksCluster-eastus_eastus
      # storageAccount: mystorageacceastus
      containerName: mytestcontainer
      # protocol: nfs
    nodeStageSecretRef:
      name: azure-secret
      namespace: expense